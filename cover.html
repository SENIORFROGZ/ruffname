
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aws: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/DataDog/datadog-agent/pkg/serverless/aws/arn.go (84.4%)</option>
				
				<option value="file1">github.com/DataDog/datadog-agent/pkg/serverless/aws/logs.go (84.6%)</option>
				
				<option value="file2">github.com/DataDog/datadog-agent/pkg/serverless/enhanced_metrics.go (95.8%)</option>
				
				<option value="file3">github.com/DataDog/datadog-agent/pkg/serverless/event_processor.go (0.0%)</option>
				
				<option value="file4">github.com/DataDog/datadog-agent/pkg/serverless/extension_const.go (0.0%)</option>
				
				<option value="file5">github.com/DataDog/datadog-agent/pkg/serverless/flush/strategy.go (95.0%)</option>
				
				<option value="file6">github.com/DataDog/datadog-agent/pkg/serverless/interval.go (96.2%)</option>
				
				<option value="file7">github.com/DataDog/datadog-agent/pkg/serverless/invoke_processor.go (56.7%)</option>
				
				<option value="file8">github.com/DataDog/datadog-agent/pkg/serverless/protocol.go (51.8%)</option>
				
				<option value="file9">github.com/DataDog/datadog-agent/pkg/serverless/registration/extension_api.go (100.0%)</option>
				
				<option value="file10">github.com/DataDog/datadog-agent/pkg/serverless/registration/logs_api.go (100.0%)</option>
				
				<option value="file11">github.com/DataDog/datadog-agent/pkg/serverless/registration/logs_api_payload.go (100.0%)</option>
				
				<option value="file12">github.com/DataDog/datadog-agent/pkg/serverless/registration/utils.go (100.0%)</option>
				
				<option value="file13">github.com/DataDog/datadog-agent/pkg/serverless/tags.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package aws

import (
        "encoding/json"
        "io/ioutil"
        "strings"
        "sync"
)

const (
        persistedStateFilePath = "/tmp/dd-lambda-extension-cache.json"
)

type persistedState struct {
        CurrentARN   string
        CurrentReqID string
}

var currentARN struct {
        value     string
        qualifier string
        sync.Mutex
}

var currentReqID struct {
        value string
        sync.Mutex
}

var currentColdStart struct {
        value bool
        sync.Mutex
}

// GetARN returns an ARN of the current running function.
// Thread-safe.
func GetARN() string <span class="cov8" title="1">{
        currentARN.Lock()
        defer currentARN.Unlock()

        return currentARN.value
}</span>

// GetQualifier returns the qualifier for the current running function.
// Thread-safe
func GetQualifier() string <span class="cov0" title="0">{
        currentARN.Lock()
        defer currentARN.Unlock()
        return currentARN.qualifier
}</span>

// GetColdStart returns whether the current invocation is a cold start
// Thread-safe
func GetColdStart() bool <span class="cov8" title="1">{
        currentColdStart.Lock()
        defer currentColdStart.Unlock()
        return currentColdStart.value
}</span>

// SetARN stores the given ARN.
// Thread-safe.
func SetARN(arn string) <span class="cov8" title="1">{
        currentARN.Lock()
        defer currentARN.Unlock()

        arn = strings.ToLower(arn)

        qualifier := ""
        // remove the version if any
        if parts := strings.Split(arn, ":"); len(parts) &gt; 7 </span><span class="cov8" title="1">{
                arn = strings.Join(parts[:7], ":")
                qualifier = strings.TrimPrefix(parts[7], "$")
        }</span>

        <span class="cov8" title="1">currentARN.value = arn
        currentARN.qualifier = qualifier</span>
}

// GetRequestID returns the currently running function request ID.
func GetRequestID() string <span class="cov8" title="1">{
        currentReqID.Lock()
        defer currentReqID.Unlock()

        return currentReqID.value
}</span>

// SetRequestID stores the currently running function request ID.
func SetRequestID(reqID string) <span class="cov8" title="1">{
        currentReqID.Lock()
        defer currentReqID.Unlock()

        currentReqID.value = reqID
}</span>

// SetColdStart stores the cold start state of the function
func SetColdStart(coldstart bool) <span class="cov8" title="1">{
        currentColdStart.Lock()
        defer currentColdStart.Unlock()

        currentColdStart.value = coldstart
}</span>

// PersistCurrentStateToFile persists the current state (ARN and Request ID) to a file.
// This allows the state to be restored after the extension restarts.
// Call this function when the extension shuts down.
func PersistCurrentStateToFile() error <span class="cov8" title="1">{
        dataToPersist := persistedState{
                CurrentARN:   GetARN(),
                CurrentReqID: GetRequestID(),
        }

        file, err := json.MarshalIndent(dataToPersist, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = ioutil.WriteFile(persistedStateFilePath, file, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RestoreCurrentStateFromFile restores the current state (ARN and Request ID) from a file
// after the extension is restarted. Call this function when the extension starts.
func RestoreCurrentStateFromFile() error <span class="cov8" title="1">{
        file, err := ioutil.ReadFile(persistedStateFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var restoredState persistedState
        err = json.Unmarshal(file, &amp;restoredState)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">SetARN(restoredState.CurrentARN)
        SetRequestID(restoredState.CurrentReqID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package aws

import (
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "time"

        logConfig "github.com/DataDog/datadog-agent/pkg/logs/config"
        "github.com/DataDog/datadog-agent/pkg/logs/scheduler"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

// logMessageTimeLayout is the layout string used to format timestamps from logs
const logMessageTimeLayout = "2006-01-02T15:04:05.999Z"

const (
        // LogTypeExtension is used to represent logs messages emitted by extensions
        LogTypeExtension = "extension"

        // LogTypeFunction is used to represent logs messages emitted by the function
        LogTypeFunction = "function"

        // LogTypePlatformStart is used for the log message about the platform starting
        LogTypePlatformStart = "platform.start"
        // LogTypePlatformEnd is used for the log message about the platform shutting down
        LogTypePlatformEnd = "platform.end"
        // LogTypePlatformReport is used for the log messages containing a report of the last invocation.
        LogTypePlatformReport = "platform.report"
        // LogTypePlatformLogsDropped is used when AWS has dropped logs because we were unable to consume them fast enough.
        LogTypePlatformLogsDropped = "platform.logsDropped"
        // LogTypePlatformLogsSubscription is used for the log messages about Logs API registration
        LogTypePlatformLogsSubscription = "platform.logsSubscription"
        // LogTypePlatformExtension is used for the log messages about Extension API registration
        LogTypePlatformExtension = "platform.extension"
)

// LogMessage is a log message sent by the AWS API.
type LogMessage struct {
        Time time.Time
        ARN  string
        Type string
        // "extension" / "function" log messages contain a record which is basically a log string
        StringRecord string `json:"record"`
        ObjectRecord PlatformObjectRecord
}

// PlatformObjectRecord contains additional information found in Platform log messages
type PlatformObjectRecord struct {
        RequestID string           // uuid; present in LogTypePlatform{Start,End,Report}
        Version   string           // present in LogTypePlatformStart only
        Metrics   ReportLogMetrics // present in LogTypePlatformReport only
}

// ReportLogMetrics contains metrics found in a LogTypePlatformReport log
type ReportLogMetrics struct {
        DurationMs       float64
        BilledDurationMs int
        MemorySizeMB     int
        MaxMemoryUsedMB  int
        InitDurationMs   float64
}

// UnmarshalJSON unmarshals the given bytes in a LogMessage object.
func (l *LogMessage) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var j map[string]interface{}
        if err := json.Unmarshal(data, &amp;j); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("LogMessage.UnmarshalJSON: can't unmarshal json: %s", err)
        }</span>

        <span class="cov8" title="1">var typ string
        var ok bool

        // type

        if typ, ok = j["type"].(string); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("LogMessage.UnmarshalJSON: malformed log message")
        }</span>

        // time

        <span class="cov8" title="1">if timeStr, ok := j["time"].(string); ok </span><span class="cov8" title="1">{
                if time, err := time.Parse(logMessageTimeLayout, timeStr); err == nil </span><span class="cov8" title="1">{
                        l.Time = time
                }</span>
        }

        // the rest

        <span class="cov8" title="1">switch typ </span>{
        case LogTypePlatformLogsSubscription, LogTypePlatformExtension:<span class="cov0" title="0">
                l.Type = typ</span>
        case LogTypeFunction, LogTypeExtension:<span class="cov8" title="1">
                l.Type = typ
                l.StringRecord = j["record"].(string)</span>
        case LogTypePlatformStart, LogTypePlatformEnd, LogTypePlatformReport:<span class="cov8" title="1">
                l.Type = typ
                if objectRecord, ok := j["record"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        // all of these have the requestId
                        if requestID, ok := objectRecord["requestId"].(string); ok </span><span class="cov8" title="1">{
                                l.ObjectRecord.RequestID = requestID
                        }</span>

                        <span class="cov8" title="1">switch typ </span>{
                        case LogTypePlatformStart:<span class="cov0" title="0">
                                SetRequestID(l.ObjectRecord.RequestID)
                                if version, ok := objectRecord["version"].(string); ok </span><span class="cov0" title="0">{
                                        l.ObjectRecord.Version = version
                                }</span>
                                <span class="cov0" title="0">l.StringRecord = fmt.Sprintf("START RequestId: %s Version: %s",
                                        l.ObjectRecord.RequestID,
                                        l.ObjectRecord.Version,
                                )</span>
                        case LogTypePlatformEnd:<span class="cov0" title="0">
                                l.StringRecord = fmt.Sprintf("END RequestId: %s",
                                        l.ObjectRecord.RequestID,
                                )</span>
                        case LogTypePlatformReport:<span class="cov8" title="1">
                                if metrics, ok := objectRecord["metrics"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        if v, ok := metrics["durationMs"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.DurationMs = v
                                        }</span>
                                        <span class="cov8" title="1">if v, ok := metrics["billedDurationMs"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.BilledDurationMs = int(v)
                                        }</span>
                                        <span class="cov8" title="1">if v, ok := metrics["memorySizeMB"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.MemorySizeMB = int(v)
                                        }</span>
                                        <span class="cov8" title="1">if v, ok := metrics["maxMemoryUsedMB"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.MaxMemoryUsedMB = int(v)
                                        }</span>
                                        <span class="cov8" title="1">if v, ok := metrics["initDurationMs"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.InitDurationMs = v
                                        }</span>
                                        <span class="cov8" title="1">log.Debugf("Enhanced metrics: %+v\n", l.ObjectRecord.Metrics)</span>
                                } else<span class="cov0" title="0"> {
                                        log.Error("LogMessage.UnmarshalJSON: can't read the metrics object")
                                }</span>
                                <span class="cov8" title="1">l.StringRecord = createStringRecordForReportLog(l)</span>
                        }
                } else<span class="cov0" title="0"> {
                        log.Error("LogMessage.UnmarshalJSON: can't read the record object")
                }</span>
        default:<span class="cov0" title="0"></span>
                // we're not parsing this kind of message yet
        }

        <span class="cov8" title="1">return nil</span>
}

// ShouldProcessLog returns whether or not the log should be further processed.
func ShouldProcessLog(arn string, lastRequestID string, message LogMessage) bool <span class="cov8" title="1">{
        // If the global request ID or ARN variable isn't set at this point, do not process further
        if arn == "" || lastRequestID == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        // Making sure that we do not process these types of logs since they are not tied to specific invovations
        <span class="cov8" title="1">if message.Type == LogTypePlatformExtension || message.Type == LogTypePlatformLogsSubscription </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func createStringRecordForReportLog(l *LogMessage) string <span class="cov8" title="1">{
        stringRecord := fmt.Sprintf("REPORT RequestId: %s\tDuration: %.2f ms\tBilled Duration: %d ms\tMemory Size: %d MB\tMax Memory Used: %d MB",
                l.ObjectRecord.RequestID,
                l.ObjectRecord.Metrics.DurationMs,
                l.ObjectRecord.Metrics.BilledDurationMs,
                l.ObjectRecord.Metrics.MemorySizeMB,
                l.ObjectRecord.Metrics.MaxMemoryUsedMB,
        )
        if l.ObjectRecord.Metrics.InitDurationMs &gt; 0 </span><span class="cov8" title="1">{
                stringRecord = stringRecord + fmt.Sprintf("\tInit Duration: %.2f ms", l.ObjectRecord.Metrics.InitDurationMs)
        }</span>

        <span class="cov8" title="1">return stringRecord</span>
}

// ParseLogsAPIPayload transforms the payload received from the Logs API to an array of LogMessage
func ParseLogsAPIPayload(data []byte) ([]LogMessage, error) <span class="cov8" title="1">{
        var messages []LogMessage
        if err := json.Unmarshal(data, &amp;messages); err != nil </span><span class="cov8" title="1">{
                // Temporary fix to handle malformed JSON tracing object : retry with sanitization
                log.Debug("Can't read log message, retry with sanitization")
                sanitizedData := removeInvalidTracingItem(data)
                if err := json.Unmarshal(sanitizedData, &amp;messages); err != nil </span><span class="cov8" title="1">{
                        return nil, errors.New("can't read log message")
                }</span>
                <span class="cov8" title="1">return messages, nil</span>
        }
        <span class="cov8" title="1">return messages, nil</span>
}

// removeInvalidTracingItem is a temporary fix to handle malformed JSON tracing object
func removeInvalidTracingItem(data []byte) []byte <span class="cov8" title="1">{
        return []byte(strings.ReplaceAll(string(data), ",\"tracing\":}", ""))
}</span>

// GetLambdaSource returns the LogSource used by the extension
func GetLambdaSource() *logConfig.LogSource <span class="cov8" title="1">{
        currentScheduler := scheduler.GetScheduler()
        if currentScheduler != nil </span><span class="cov8" title="1">{
                source := currentScheduler.GetSourceFromName("lambda")
                if source != nil </span><span class="cov8" title="1">{
                        return source
                }</span>
        }
        <span class="cov8" title="1">log.Debug("Impossible to retrieve the lambda LogSource")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package serverless

import (
        "fmt"
        "math"
        "strings"
        "time"

        "github.com/DataDog/datadog-agent/pkg/metrics"
        "github.com/DataDog/datadog-agent/pkg/serverless/aws"
)

// Latest Lambda pricing per https://aws.amazon.com/lambda/pricing/
const (
        baseLambdaInvocationPrice = 0.0000002
        lambdaPricePerGbSecond    = 0.0000166667
        msToSec                   = 0.001
)

func getOutOfMemorySubstrings() []string <span class="cov8" title="1">{
        return []string{
                "fatal error: runtime: out of memory",       // Go
                "java.lang.OutOfMemoryError",                // Java
                "JavaScript heap out of memory",             // Node
                "Runtime exited with error: signal: killed", // Node
                "MemoryError", // Python
                "failed to allocate memory (NoMemoryError)", // Ruby
        }
}</span>

// generateEnhancedMetricsFromRegularLog generates enhanced metrics from a LogTypeFunction message
func generateEnhancedMetricsFromFunctionLog(message aws.LogMessage, tags []string, metricsChan chan []metrics.MetricSample) <span class="cov8" title="1">{
        logString := message.StringRecord
        for _, substring := range getOutOfMemorySubstrings() </span><span class="cov8" title="1">{
                if strings.Contains(logString, substring) </span><span class="cov8" title="1">{
                        metricsChan &lt;- []metrics.MetricSample{{
                                Name:       "aws.lambda.enhanced.out_of_memory",
                                Value:      1.0,
                                Mtype:      metrics.DistributionType,
                                Tags:       tags,
                                SampleRate: 1,
                                Timestamp:  float64(message.Time.UnixNano()),
                        }}
                        return
                }</span>
        }
}

// generateEnhancedMetricsFromReportLog generates enhanced metrics from a LogTypePlatformReport log message
func generateEnhancedMetricsFromReportLog(message aws.LogMessage, tags []string, metricsChan chan []metrics.MetricSample) <span class="cov8" title="1">{
        memorySizeMb := float64(message.ObjectRecord.Metrics.MemorySizeMB)
        billedDurationMs := float64(message.ObjectRecord.Metrics.BilledDurationMs)

        enhancedMetrics := []metrics.MetricSample{{
                Name:       "aws.lambda.enhanced.max_memory_used",
                Value:      float64(message.ObjectRecord.Metrics.MaxMemoryUsedMB),
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  float64(message.Time.UnixNano()),
        }, {
                Name:       "aws.lambda.enhanced.memorysize",
                Value:      memorySizeMb,
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  float64(message.Time.UnixNano()),
        }, {
                Name:       "aws.lambda.enhanced.billed_duration",
                Value:      billedDurationMs * msToSec,
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  float64(message.Time.UnixNano()),
        }, {
                Name:       "aws.lambda.enhanced.duration",
                Value:      message.ObjectRecord.Metrics.DurationMs * msToSec,
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  float64(message.Time.UnixNano()),
        }, {
                Name:       "aws.lambda.enhanced.estimated_cost",
                Value:      calculateEstimatedCost(billedDurationMs, memorySizeMb),
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  float64(message.Time.UnixNano()),
        }}
        if message.ObjectRecord.Metrics.InitDurationMs &gt; 0 </span><span class="cov8" title="1">{
                initDurationMetric := metrics.MetricSample{
                        Name:       "aws.lambda.enhanced.init_duration",
                        Value:      message.ObjectRecord.Metrics.InitDurationMs * msToSec,
                        Mtype:      metrics.DistributionType,
                        Tags:       tags,
                        SampleRate: 1,
                        Timestamp:  float64(message.Time.UnixNano()),
                }
                enhancedMetrics = append(enhancedMetrics, initDurationMetric)
        }</span>
        <span class="cov8" title="1">metricsChan &lt;- enhancedMetrics</span>
}

// sendTimeoutEnhancedMetric sends an enhanced metric representing a timeout
func sendTimeoutEnhancedMetric(tags []string, metricsChan chan []metrics.MetricSample) <span class="cov8" title="1">{
        metricsChan &lt;- []metrics.MetricSample{{
                Name:       "aws.lambda.enhanced.timeouts",
                Value:      1.0,
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  float64(time.Now().UnixNano()),
        }}
}</span>

// addColdStartTag appends the cold_start tag to existing tags
func addColdStartTag(tags []string) []string <span class="cov8" title="1">{
        coldStart := aws.GetColdStart()
        tags = append(tags, fmt.Sprintf("cold_start:%v", coldStart))
        return tags
}</span>

// calculateEstimatedCost returns the estimated cost in USD of a Lambda invocation
func calculateEstimatedCost(billedDurationMs float64, memorySizeMb float64) float64 <span class="cov8" title="1">{
        billedDurationSeconds := billedDurationMs / 1000.0
        memorySizeGb := memorySizeMb / 1024.0
        gbSeconds := billedDurationSeconds * memorySizeGb
        // round the final float result because float math could have float point imprecision
        // on some arch. (i.e. 1.00000000000002 values)
        return math.Round((baseLambdaInvocationPrice+(gbSeconds*lambdaPricePerGbSecond))*10e12) / 10e12
}</span>

// generateEnhancedMetrics generates enhanced metrics from logs and dispatch them to the chan
func generateEnhancedMetrics(message aws.LogMessage, tags []string, metricsChan chan []metrics.MetricSample) <span class="cov8" title="1">{
        switch message.Type </span>{
        case aws.LogTypeFunction:<span class="cov0" title="0">
                generateEnhancedMetricsFromFunctionLog(message, tags, metricsChan)</span>
        case aws.LogTypePlatformReport:<span class="cov8" title="1">
                generateEnhancedMetricsFromReportLog(message, tags, metricsChan)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package serverless

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "strings"
        "time"

        "github.com/DataDog/datadog-agent/pkg/metrics"
        "github.com/DataDog/datadog-agent/pkg/serverless/registration"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

const (
        routeEventNext string = "/2020-01-01/extension/event/next"
)

// Payload is the payload read in the response while subscribing to
// the AWS Extension env.
type Payload struct {
        EventType          RuntimeEvent   `json:"eventType"`
        DeadlineMs         int64          `json:"deadlineMs"`
        InvokedFunctionArn string         `json:"invokedFunctionArn"`
        ShutdownReason     ShutdownReason `json:"shutdownReason"`
        //    RequestId string `json:"requestId"` // unused
}

// WaitForNextEvent makes a blocking HTTP call to receive the next event from AWS.
// Note that for now, we only subscribe to INVOKE and SHUTDOWN events.
// Write into stopCh to stop the main thread of the running program.
func WaitForNextEvent(stopCh chan struct{}, daemon *Daemon, metricsChan chan []metrics.MetricSample, id registration.ID, coldstart bool, prefix string) error <span class="cov0" title="0">{
        var err error
        var request *http.Request
        var response *http.Response

        if request, err = http.NewRequest(http.MethodGet, registration.BuildURL(prefix, routeEventNext), nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WaitForNextInvocation: can't create the GET request: %v", err)
        }</span>
        <span class="cov0" title="0">request.Header.Set(registration.HeaderExtID, id.String())

        // make a blocking HTTP call to wait for the next event from AWS
        log.Debug("Waiting for next invocation...")
        client := &amp;http.Client{Timeout: 0} // this one should never timeout
        if response, err = client.Do(request); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WaitForNextInvocation: while GET next route: %v", err)
        }</span>
        <span class="cov0" title="0">daemon.StartInvocation()

        // we received an INVOKE or SHUTDOWN event
        daemon.StoreInvocationTime(time.Now())

        var body []byte
        if body, err = ioutil.ReadAll(response.Body); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WaitForNextInvocation: can't read the body: %v", err)
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        var payload Payload
        if err := json.Unmarshal(body, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WaitForNextInvocation: can't unmarshal the payload: %v", err)
        }</span>

        <span class="cov0" title="0">if payload.EventType == Invoke </span><span class="cov0" title="0">{
                callInvocationHandler(daemon, payload.InvokedFunctionArn, payload.DeadlineMs, safetyBufferTimeout, coldstart, handleInvocation)
        }</span>
        <span class="cov0" title="0">if payload.EventType == Shutdown </span><span class="cov0" title="0">{
                log.Debug("Received shutdown event. Reason: " + payload.ShutdownReason)
                isTimeout := strings.ToLower(payload.ShutdownReason.String()) == Timeout.String()
                if isTimeout </span><span class="cov0" title="0">{
                        metricTags := addColdStartTag(daemon.extraTags)
                        sendTimeoutEnhancedMetric(metricTags, metricsChan)
                }</span>
                <span class="cov0" title="0">daemon.Stop(isTimeout)
                stopCh &lt;- struct{}{}</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package serverless

const (
        // Invoke event
        Invoke RuntimeEvent = "INVOKE"
        // Shutdown event
        Shutdown RuntimeEvent = "SHUTDOWN"
        // Timeout is one of the possible ShutdownReasons
        Timeout ShutdownReason = "timeout"
)

// ShutdownReason is an AWS Shutdown reason
type ShutdownReason string

// RuntimeEvent is an AWS Runtime event
type RuntimeEvent string

// ErrorEnum are errors reported to the AWS Extension environment.
type ErrorEnum string

// String returns the string value for this ErrorEnum.
func (e ErrorEnum) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

// String returns the string value for this ShutdownReason.
func (s ShutdownReason) String() string <span class="cov0" title="0">{
        return string(s)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package flush

import (
        "fmt"
        "strconv"
        "strings"
        "time"
)

// Strategy is deciding whether the data should be flushed or not at the given moment.
type Strategy interface {
        String() string
        ShouldFlush(moment Moment, t time.Time) bool
}

// Moment represents at which moment we're asking the flush strategy if we
// should flush or not.
// Note that there is no entry for the shutdown of the environment because we always
// flush in this situation.
type Moment string

const (
        // Starting is used to represent the moment the function is starting because
        // it has been invoked.
        Starting Moment = "starting"
        // Stopping is used to represent the moment right after the function has finished
        // its execution.
        Stopping Moment = "stopping"
)

// StrategyFromString returns a flush strategy from the given string.
// Possible values:
//   - end
//   - periodically[,milliseconds]
func StrategyFromString(str string) (Strategy, error) <span class="cov8" title="1">{
        switch str </span>{
        case "end":<span class="cov8" title="1">
                return &amp;AtTheEnd{}, nil</span>
        case "periodically":<span class="cov8" title="1">
                return NewPeriodically(10 * time.Second), nil</span>
        }

        <span class="cov8" title="1">if strings.HasPrefix(str, "periodically") &amp;&amp; strings.Count(str, ",") == 1 </span><span class="cov8" title="1">{
                parts := strings.Split(str, ",")

                msecs, err := strconv.Atoi(parts[1])
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;AtTheEnd{}, fmt.Errorf("StrategyFromString: can't parse flush strategy: %s", str)
                }</span>

                <span class="cov8" title="1">return NewPeriodically(time.Duration(msecs) * time.Millisecond), nil</span>
        }

        <span class="cov8" title="1">return &amp;AtTheEnd{}, fmt.Errorf("StrategyFromString: can't parse flush strategy: %s", str)</span>
}

// -----

// AtTheEnd strategy is the simply flushing the data at the end of the execution of the function.
type AtTheEnd struct{}

func (s *AtTheEnd) String() string <span class="cov8" title="1">{ return "end" }</span>

// ShouldFlush returns true if this strategy want to flush at the given moment.
func (s *AtTheEnd) ShouldFlush(moment Moment, t time.Time) bool <span class="cov8" title="1">{
        return moment == Stopping
}</span>

// Periodically is the strategy flushing at least every N [nano/micro/milli]seconds
// at the start of the function.
type Periodically struct {
        interval  time.Duration
        lastFlush time.Time
}

// NewPeriodically returns an initialized Periodically flush strategy.
func NewPeriodically(interval time.Duration) *Periodically <span class="cov8" title="1">{
        return &amp;Periodically{interval: interval}
}</span>

func (s *Periodically) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("periodically,%d", s.interval/time.Millisecond)
}</span>

// ShouldFlush returns true if this strategy want to flush at the given moment.
func (s *Periodically) ShouldFlush(moment Moment, t time.Time) bool <span class="cov8" title="1">{
        if moment == Starting </span><span class="cov8" title="1">{
                now := time.Now()
                if s.lastFlush.Add(s.interval).Before(now) </span><span class="cov8" title="1">{
                        s.lastFlush = now
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package serverless

import (
        "time"

        "github.com/DataDog/datadog-agent/pkg/serverless/flush"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

const maxInvocationsStored = 10

// StoreInvocationTime stores the given invocation time in the list of previous
// invocations. It is used to compute the invocation interval of the current function.
// It is automatically removing entries when too much have been already stored (more than maxInvocationsStored).
// When trying to store a new point, if it is older than the last one stored, it is ignored.
// Returns if the point has been stored.
func (d *Daemon) StoreInvocationTime(t time.Time) bool <span class="cov8" title="1">{
        // ignore points older than the last stored one
        if len(d.lastInvocations) &gt; 0 &amp;&amp; d.lastInvocations[len(d.lastInvocations)-1].After(t) </span><span class="cov0" title="0">{
                return false
        }</span>

        // remove when too much/old entries
        <span class="cov8" title="1">d.lastInvocations = append(d.lastInvocations, t)
        if len(d.lastInvocations) &gt; maxInvocationsStored </span><span class="cov8" title="1">{
                d.lastInvocations = d.lastInvocations[len(d.lastInvocations)-maxInvocationsStored : len(d.lastInvocations)]
        }</span>

        <span class="cov8" title="1">return true</span>
}

// InvocationInterval computes the invocation interval of the current function.
// This function returns 0 if not enough invocations were done.
func (d *Daemon) InvocationInterval() time.Duration <span class="cov8" title="1">{
        // with less than 3 invocations, we don't have enough data to compute
        // something reliable.
        if len(d.lastInvocations) &lt; 3 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var total int64
        for i := 1; i &lt; len(d.lastInvocations); i++ </span><span class="cov8" title="1">{
                total += int64(d.lastInvocations[i].Sub(d.lastInvocations[i-1]))
        }</span>

        <span class="cov8" title="1">return time.Duration(total / int64(len(d.lastInvocations)-1))</span>
}

// AutoSelectStrategy uses the invocation interval of the function to select the
// best flush strategy.
// This function doesn't mind if the flush strategy has been overridden through
// configuration / environment var, the caller is responsible of that.
func (d *Daemon) AutoSelectStrategy() flush.Strategy <span class="cov8" title="1">{
        flushInterval := 10 * time.Second
        freq := d.InvocationInterval()

        if !d.clientLibReady </span><span class="cov8" title="1">{
                return flush.NewPeriodically(flushInterval)
        }</span>

        // when not enough data is available, fallback on flush.AtTheEnd strategy
        <span class="cov8" title="1">if freq == time.Duration(0) </span><span class="cov8" title="1">{
                return &amp;flush.AtTheEnd{}
        }</span>

        // if running more than 1 time every 5 minutes, we can switch to the flush strategy
        // flushing at least every 10 seconds (at the start of the invocation)
        // TODO(remy): compute a proper interval instead of hard-coding 10 seconds
        <span class="cov8" title="1">if freq.Seconds() &lt; 60*5 </span><span class="cov8" title="1">{
                return flush.NewPeriodically(flushInterval)
        }</span>

        <span class="cov8" title="1">return &amp;flush.AtTheEnd{}</span>
}

// UpdateStrategy will update the current flushing strategy
func (d *Daemon) UpdateStrategy() <span class="cov8" title="1">{
        if d.useAdaptiveFlush </span><span class="cov8" title="1">{
                newStrat := d.AutoSelectStrategy()
                if newStrat.String() != d.flushStrategy.String() </span><span class="cov8" title="1">{
                        log.Debug("Switching to flush strategy:", newStrat)
                        d.flushStrategy = newStrat
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package serverless

import (
        "context"
        "time"

        "github.com/DataDog/datadog-agent/pkg/config"
        "github.com/DataDog/datadog-agent/pkg/serverless/aws"
        "github.com/DataDog/datadog-agent/pkg/serverless/flush"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

const (
        clientReadyTimeout  time.Duration = 2 * time.Second
        safetyBufferTimeout time.Duration = 20 * time.Millisecond
)

// InvocationHandler is the invocation handler signature
type InvocationHandler func(doneChannel chan bool, daemon *Daemon, arn string, coldstart bool)

func callInvocationHandler(daemon *Daemon, arn string, deadlineMs int64, safetyBufferTimeout time.Duration, coldstart bool, invocationHandler InvocationHandler) <span class="cov8" title="1">{
        timeout := computeTimeout(time.Now(), deadlineMs, safetyBufferTimeout)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        doneChannel := make(chan bool)
        go invocationHandler(doneChannel, daemon, arn, coldstart)
        select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                log.Debug("Timeout detected, finishing the current invocation now to allow receiving the SHUTDOWN event")
                daemon.FinishInvocation()
                return</span>
        case &lt;-doneChannel:<span class="cov0" title="0">
                return</span>
        }
}

func handleInvocation(doneChannel chan bool, daemon *Daemon, arn string, coldstart bool) <span class="cov8" title="1">{
        log.Debug("Received invocation event...")
        daemon.ComputeGlobalTags(arn, config.GetConfiguredTags(true))
        aws.SetARN(arn)
        if coldstart </span><span class="cov8" title="1">{
                ready := daemon.WaitUntilClientReady(clientReadyTimeout)
                if ready </span><span class="cov0" title="0">{
                        log.Debug("Client library registered with extension")
                }</span> else<span class="cov0" title="0"> {
                        log.Debug("Timed out waiting for client library to register with extension.")
                }</span>
                <span class="cov0" title="0">daemon.UpdateStrategy()</span>
        }

        // immediately check if we should flush data
        // note that since we're flushing synchronously here, there is a scenario
        // where this could be blocking the function if the flush is slow (if the
        // extension is not quickly going back to listen on the "wait next event"
        // route). That's why we use a context.Context with a timeout `flushTimeout``
        // to avoid blocking for too long.
        // This flushTimeout is re-using the forwarder_timeout value.
        <span class="cov0" title="0">if daemon.flushStrategy.ShouldFlush(flush.Starting, time.Now()) </span><span class="cov0" title="0">{
                log.Debugf("The flush strategy %s has decided to flush the data in the moment: %s", daemon.flushStrategy, flush.Starting)
                flushTimeout := config.Datadog.GetDuration("forwarder_timeout") * time.Second
                ctx, cancel := context.WithTimeout(context.Background(), flushTimeout)
                daemon.TriggerFlush(ctx, false)
                cancel() // free the resource of the context
        }</span> else<span class="cov0" title="0"> {
                log.Debugf("The flush strategy %s has decided to not flush in the moment: %s", daemon.flushStrategy, flush.Starting)
        }</span>
        <span class="cov0" title="0">daemon.WaitForDaemon()
        doneChannel &lt;- true</span>
}

func computeTimeout(now time.Time, deadlineMs int64, safetyBuffer time.Duration) time.Duration <span class="cov8" title="1">{
        currentTimeInMs := now.UnixNano() / int64(time.Millisecond)
        return time.Duration((deadlineMs-currentTimeInMs)*int64(time.Millisecond) - int64(safetyBuffer))
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package serverless

import (
        "context"
        "fmt"
        "io/ioutil"
        "net/http"
        "sync"
        "time"

        "github.com/DataDog/datadog-agent/pkg/aggregator"
        "github.com/DataDog/datadog-agent/pkg/config"
        "github.com/DataDog/datadog-agent/pkg/dogstatsd"
        "github.com/DataDog/datadog-agent/pkg/logs"
        logConfig "github.com/DataDog/datadog-agent/pkg/logs/config"
        "github.com/DataDog/datadog-agent/pkg/metrics"
        "github.com/DataDog/datadog-agent/pkg/serverless/aws"
        "github.com/DataDog/datadog-agent/pkg/serverless/flush"
        traceAgent "github.com/DataDog/datadog-agent/pkg/trace/agent"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

// httpServerPort will be the default port used to run the HTTP server listening
// to calls from the client libraries and to logs from the AWS environment.
const httpServerPort int = 8124

const httpLogsCollectionRoute string = "/lambda/logs"

// shutdownDelay is the amount of time we wait before shutting down the HTTP server
// after we receive a Shutdown event. This allows time for the final log messages
// to arrive from the Logs API.
const shutdownDelay time.Duration = 1 * time.Second

// Daemon is the communcation server for between the runtime and the serverless Agent.
// The name "daemon" is just in order to avoid serverless.StartServer ...
type Daemon struct {
        httpServer *http.Server
        mux        *http.ServeMux

        statsdServer *dogstatsd.Server

        traceAgent     *traceAgent.Agent
        stopTraceAgent context.CancelFunc

        // lastInvocations stores last invocation times to be able to compute the
        // interval of invocation of the function.
        lastInvocations []time.Time

        // flushStrategy is the currently selected flush strategy, defaulting to the
        // the "flush at the end" naive strategy.
        flushStrategy flush.Strategy

        // useAdaptiveFlush is set to false when the flush strategy has been forced
        // through configuration.
        useAdaptiveFlush bool

        // clientLibReady indicates whether the datadog client library has initialised
        // and called the /hello route on the agent
        clientLibReady bool

        // aggregator used by the statsd server
        aggregator *aggregator.BufferedAggregator

        // stopped represents whether the Daemon has been stopped
        stopped bool
        // Wait on this WaitGroup in controllers to be sure that the Daemon is ready.
        // (i.e. that the DogStatsD server is properly instantiated)
        ReadyWg *sync.WaitGroup

        // Wait on this WaitGroup to be sure that the daemon isn't doing any pending
        // work before finishing an invocation
        InvcWg *sync.WaitGroup

        extraTags []string

        // finishInvocationOnce assert that FinishedInvocation will be called only once (at the end of the function OR after a timeout)
        // this should be reset before each invocation
        finishInvocationOnce sync.Once
}

// SetStatsdServer sets the DogStatsD server instance running when it is ready.
func (d *Daemon) SetStatsdServer(statsdServer *dogstatsd.Server) <span class="cov0" title="0">{
        d.statsdServer = statsdServer
}</span>

// SetTraceAgent sets the Agent instance for submitting traces
func (d *Daemon) SetTraceAgent(traceAgent *traceAgent.Agent) <span class="cov0" title="0">{
        d.traceAgent = traceAgent
}</span>

// SetAggregator sets the aggregator used within the DogStatsD server.
// Use this aggregator `GetChannels()` or `GetBufferedChannels()` to send metrics
// directly to the aggregator, with caution.
func (d *Daemon) SetAggregator(aggregator *aggregator.BufferedAggregator) <span class="cov0" title="0">{
        d.aggregator = aggregator
}</span>

// SetFlushStrategy sets the flush strategy to use.
func (d *Daemon) SetFlushStrategy(strategy flush.Strategy) <span class="cov0" title="0">{
        log.Debugf("Set flush strategy: %s (was: %s)", strategy.String(), d.flushStrategy.String())
        d.flushStrategy = strategy
}</span>

// UseAdaptiveFlush sets whether we use the adaptive flush or not.
// Set it to false when the flush strategy has been forced through configuration.
func (d *Daemon) UseAdaptiveFlush(enabled bool) <span class="cov0" title="0">{
        d.useAdaptiveFlush = enabled
}</span>

// TriggerFlush triggers a flush of the aggregated metrics, traces and logs.
// They are flushed concurrently.
// In some circumstances, it may switch to another flush strategy after the flush.
// isLastFlush indicates whether this is the last flush before the shutdown or not.
func (d *Daemon) TriggerFlush(ctx context.Context, isLastFlush bool) <span class="cov8" title="1">{
        // Increment the invocation wait group which tracks whether work is in progress for the daemon
        d.InvcWg.Add(1)
        defer d.InvcWg.Done()
        wg := sync.WaitGroup{}
        wg.Add(1)
        wg.Add(1)
        wg.Add(1)

        // metrics
        go func() </span><span class="cov8" title="1">{
                if d.statsdServer != nil </span><span class="cov0" title="0">{
                        d.statsdServer.Flush()
                }</span>
                <span class="cov8" title="1">wg.Done()</span>
        }()

        // traces
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if d.traceAgent != nil </span><span class="cov0" title="0">{
                        d.traceAgent.FlushSync()
                }</span>
                <span class="cov8" title="1">wg.Done()</span>
        }()

        // logs
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                logs.Flush(ctx)
                wg.Done()
        }</span>()

        <span class="cov8" title="1">wg.Wait()
        log.Debug("Flush done")

        // After flushing, re-evaluate flush strategy (if applicable)
        if !isLastFlush </span><span class="cov0" title="0">{
                d.UpdateStrategy()
        }</span>
}

// Stop causes the Daemon to gracefully shut down. After a delay, the HTTP server
// is shut down, data is flushed a final time, and then the agents are shut down.
func (d *Daemon) Stop(isTimeout bool) <span class="cov8" title="1">{
        // Can't shut down before starting
        // If the DogStatsD daemon isn't ready, wait for it.
        d.ReadyWg.Wait()

        if d.stopped </span><span class="cov0" title="0">{
                log.Debug("Daemon.Stop() was called, but Daemon was already stopped")
                return
        }</span>
        <span class="cov8" title="1">d.stopped = true

        if !isTimeout </span><span class="cov8" title="1">{
                // Wait for any remaining logs to arrive via the logs API before shutting down the HTTP server
                log.Debug("Waiting to shut down HTTP server")
                time.Sleep(shutdownDelay)
        }</span>

        <span class="cov8" title="1">log.Debug("Shutting down HTTP server")
        err := d.httpServer.Shutdown(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Error shutting down HTTP server")
        }</span>

        <span class="cov8" title="1">err = aws.PersistCurrentStateToFile()
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Unable to persist current state to file while shutting down")
        }</span>

        // Once the HTTP server is shut down, it is safe to shut down the agents
        // Otherwise, we might try to handle API calls after the agent has already been shut down
        <span class="cov8" title="1">d.TriggerFlush(context.Background(), true)

        log.Debug("Shutting down agents")
        d.stopTraceAgent()
        if d.statsdServer != nil </span><span class="cov0" title="0">{
                d.statsdServer.Stop()
        }</span>
        <span class="cov8" title="1">logs.Stop()
        log.Debug("Serverless agent shutdown complete")</span>
}

// StartDaemon starts an HTTP server to receive messages from the runtime.
// The DogStatsD server is provided when ready (slightly later), to have the
// hello route available as soon as possible. However, the HELLO route is blocking
// to have a way for the runtime function to know when the Serverless Agent is ready.
// If the Flush route is called before the statsd server has been set, a 503
// is returned by the HTTP route.
func StartDaemon(stopTraceAgent context.CancelFunc) *Daemon <span class="cov8" title="1">{
        log.Debug("Starting daemon to receive messages from runtime...")
        mux := http.NewServeMux()

        daemon := &amp;Daemon{
                statsdServer:     nil,
                httpServer:       &amp;http.Server{Addr: fmt.Sprintf(":%d", httpServerPort), Handler: mux},
                stopTraceAgent:   stopTraceAgent,
                mux:              mux,
                ReadyWg:          &amp;sync.WaitGroup{},
                InvcWg:           &amp;sync.WaitGroup{},
                lastInvocations:  make([]time.Time, 0),
                useAdaptiveFlush: true,
                clientLibReady:   false,
                flushStrategy:    &amp;flush.AtTheEnd{},
                extraTags:        nil,
        }

        log.Debug("Adaptive flush is enabled")

        mux.Handle("/lambda/hello", &amp;Hello{daemon})
        mux.Handle("/lambda/flush", &amp;Flush{daemon})

        // this wait group will be blocking until the DogStatsD server has been instantiated
        daemon.ReadyWg.Add(1)

        // start the HTTP server used to communicate with the clients
        go func() </span><span class="cov8" title="1">{
                if err := daemon.httpServer.ListenAndServe(); err != nil </span><span class="cov8" title="1">{
                        log.Error(err)
                }</span>
        }()

        <span class="cov8" title="1">return daemon</span>
}

// EnableLogsCollection is adding the HTTP route on which the HTTP server will receive
// logs from AWS.
// Returns the HTTP URL on which AWS should send the logs.
func (d *Daemon) EnableLogsCollection() (string, chan *logConfig.ChannelMessage, error) <span class="cov0" title="0">{
        httpAddr := fmt.Sprintf("http://sandbox:%d%s", httpServerPort, httpLogsCollectionRoute)
        logsChan := make(chan *logConfig.ChannelMessage)
        d.mux.Handle(httpLogsCollectionRoute, &amp;LogsCollection{daemon: d, ch: logsChan})
        log.Debugf("Logs collection route has been initialized. Logs must be sent to %s", httpAddr)
        return httpAddr, logsChan, nil
}</span>

// StartInvocation tells the daemon the invocation began
func (d *Daemon) StartInvocation() <span class="cov8" title="1">{
        d.finishInvocationOnce = sync.Once{}
        d.InvcWg.Add(1)
}</span>

// FinishInvocation finishes the current invocation
func (d *Daemon) FinishInvocation() <span class="cov8" title="1">{
        d.finishInvocationOnce.Do(func() </span><span class="cov8" title="1">{
                d.InvcWg.Done()
        }</span>)
}

// WaitForDaemon waits until invocation finished any pending work
func (d *Daemon) WaitForDaemon() <span class="cov8" title="1">{
        if d.clientLibReady </span><span class="cov8" title="1">{
                d.InvcWg.Wait()
        }</span>
}

// WaitUntilClientReady will wait until the client library has called the /hello route, or timeout
func (d *Daemon) WaitUntilClientReady(timeout time.Duration) bool <span class="cov8" title="1">{
        checkInterval := 10 * time.Millisecond
        for timeout &gt; checkInterval </span><span class="cov8" title="1">{
                if d.clientLibReady </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">&lt;-time.After(checkInterval)
                timeout -= checkInterval</span>
        }
        <span class="cov8" title="1">&lt;-time.After(timeout)
        return d.clientLibReady</span>
}

// ComputeGlobalTags extracts tags from the ARN, merges them with any user-defined tags and adds them to traces, logs and metrics
func (d *Daemon) ComputeGlobalTags(arn string, configTags []string) <span class="cov8" title="1">{
        if len(d.extraTags) == 0 </span><span class="cov8" title="1">{
                tagMap := buildTagMap(arn, configTags)
                tagArray := buildTagsFromMap(tagMap)
                if d.statsdServer != nil </span><span class="cov0" title="0">{
                        d.statsdServer.SetExtraTags(tagArray)
                }</span>
                <span class="cov8" title="1">if d.traceAgent != nil </span><span class="cov0" title="0">{
                        d.traceAgent.SetGlobalTags(buildTracerTags(tagMap))
                }</span>
                <span class="cov8" title="1">d.extraTags = tagArray
                source := aws.GetLambdaSource()
                if source != nil </span><span class="cov0" title="0">{
                        source.Config.Tags = tagArray
                }</span>
        }
}

// LogsCollection is the route on which the AWS environment is sending the logs
// for the extension to collect them. It is attached to the main HTTP server
// already receiving hits from the libraries client.
type LogsCollection struct {
        daemon *Daemon
        ch     chan *logConfig.ChannelMessage
}

// ServeHTTP - see type LogsCollection comment.
func (l *LogsCollection) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // If the DogStatsD daemon isn't ready, wait for it.
        l.daemon.ReadyWg.Wait()

        data, _ := ioutil.ReadAll(r.Body)
        defer r.Body.Close()

        messages, err := aws.ParseLogsAPIPayload(data)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(400)
        }</span> else<span class="cov0" title="0"> {
                processLogMessages(l, messages)
                w.WriteHeader(200)
        }</span>
}

func processLogMessages(l *LogsCollection, messages []aws.LogMessage) <span class="cov0" title="0">{
        metricsChan := l.daemon.aggregator.GetBufferedMetricsWithTsChannel()
        metricTags := addColdStartTag(l.daemon.extraTags)
        logsEnabled := config.Datadog.GetBool("serverless.logs_enabled")
        enhancedMetricsEnabled := config.Datadog.GetBool("enhanced_metrics")
        arn := aws.GetARN()
        lastRequestID := aws.GetRequestID()
        for _, message := range messages </span><span class="cov0" title="0">{
                processMessage(message, arn, lastRequestID, enhancedMetricsEnabled, metricTags, metricsChan)
                // We always collect and process logs for the purpose of extracting enhanced metrics.
                // However, if logs are not enabled, we do not send them to the intake.
                if logsEnabled </span><span class="cov0" title="0">{
                        logMessage := logConfig.NewChannelMessageFromLambda([]byte(message.StringRecord), message.Time, arn, lastRequestID)
                        l.ch &lt;- logMessage
                }</span>
        }
}

// processMessage performs logic about metrics and tags on the message
func processMessage(message aws.LogMessage, arn string, lastRequestID string, computeEnhancedMetrics bool, metricTags []string, metricsChan chan []metrics.MetricSample) <span class="cov8" title="1">{
        // Do not send logs or metrics if we can't associate them with an ARN or Request ID
        // First, if the log has a Request ID, set the global Request ID variable
        if message.Type == aws.LogTypePlatformStart </span><span class="cov0" title="0">{
                if len(message.ObjectRecord.RequestID) &gt; 0 </span><span class="cov0" title="0">{
                        aws.SetRequestID(message.ObjectRecord.RequestID)
                        lastRequestID = message.ObjectRecord.RequestID
                }</span>
        }

        <span class="cov8" title="1">if !aws.ShouldProcessLog(arn, lastRequestID, message) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if computeEnhancedMetrics </span><span class="cov8" title="1">{
                generateEnhancedMetrics(message, metricTags, metricsChan)
        }</span>

        <span class="cov8" title="1">switch message.Type </span>{
        case aws.LogTypePlatformReport:<span class="cov8" title="1">
                aws.SetColdStart(false)</span>
        case aws.LogTypePlatformLogsDropped:<span class="cov0" title="0">
                log.Debug("Logs were dropped by the AWS Lambda Logs API")</span>
        }
}

// Hello implements the basic Hello route, creating a way for the Datadog Lambda Library
// to know that the serverless agent is running. It is blocking until the DogStatsD daemon is ready.
type Hello struct {
        daemon *Daemon
}

// ServeHTTP - see type Hello comment.
func (h *Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Debug("Hit on the serverless.Hello route.")
        // if the DogStatsD daemon isn't ready, wait for it.
        h.daemon.clientLibReady = true
        h.daemon.ReadyWg.Wait()
}</span>

// Flush is the route to call to do an immediate flush on the serverless agent.
// Returns 503 if the DogStatsD is not ready yet, 200 otherwise.
type Flush struct {
        daemon *Daemon
}

// ServeHTTP - see type Flush comment.
func (f *Flush) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Debug("Hit on the serverless.Flush route.")
        if !f.daemon.flushStrategy.ShouldFlush(flush.Stopping, time.Now()) </span><span class="cov0" title="0">{
                log.Debug("The flush strategy", f.daemon.flushStrategy, " has decided to not flush in moment:", flush.Stopping)
                f.daemon.FinishInvocation()
                return
        }</span>

        <span class="cov0" title="0">log.Debug("The flush strategy", f.daemon.flushStrategy, " has decided to flush in moment:", flush.Stopping)

        // if the DogStatsD daemon isn't ready, wait for it.
        f.daemon.ReadyWg.Wait()
        if f.daemon.statsdServer == nil </span><span class="cov0" title="0">{
                w.WriteHeader(503)
                w.Write([]byte("DogStatsD server not ready"))
                f.daemon.FinishInvocation()
                return
        }</span>

        // note that I am not using the request context because I think that we don't
        // want the flush to be canceled if the client is closing the request.
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                flushTimeout := config.Datadog.GetDuration("forwarder_timeout") * time.Second
                ctx, cancel := context.WithTimeout(context.Background(), flushTimeout)
                f.daemon.TriggerFlush(ctx, false)
                f.daemon.FinishInvocation()
                cancel()
        }</span>()

}
</pre>
		
		<pre class="file" id="file9" style="display: none">package registration

import (
        "bytes"
        "fmt"
        "net/http"
        "time"
)

const (
        extensionName = "datadog-agent"
        headerExtName = "Lambda-Extension-Name"
        HeaderExtID   = "Lambda-Extension-Identifier"
)

// Register registers the serverless daemon and subscribe to INVOKE and SHUTDOWN messages.
// Returns either (the serverless ID assigned by the serverless daemon + the api key as read from
// the environment) or an error.
func Register(url string, timeout time.Duration) (ID, error) <span class="cov8" title="1">{
        payload := createRegistrationPayload()

        request, err := buildRegisterRequest(headerExtName, extensionName, url, payload)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Register: can't create the POST register request: %v", err)
        }</span>

        <span class="cov8" title="1">response, err := sendRequest(&amp;http.Client{Timeout: timeout}, request)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Register: error while POST register route: %v", err)
        }</span>

        <span class="cov8" title="1">if !isAValidResponse(response) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Register: didn't receive an HTTP 200")
        }</span>

        <span class="cov8" title="1">id := extractId(response)
        if len(id) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Register: didn't receive an identifier")
        }</span>

        <span class="cov8" title="1">return ID(id), nil</span>
}

func createRegistrationPayload() *bytes.Buffer <span class="cov8" title="1">{
        payload := bytes.NewBuffer(nil)
        payload.Write([]byte(`{"events":["INVOKE", "SHUTDOWN"]}`))
        return payload
}</span>

func extractId(response *http.Response) string <span class="cov8" title="1">{
        return response.Header.Get(HeaderExtID)
}</span>

func isAValidResponse(response *http.Response) bool <span class="cov8" title="1">{
        return response.StatusCode == 200
}</span>

func buildRegisterRequest(headerExtensionName string, extensionName string, url string, payload *bytes.Buffer) (*http.Request, error) <span class="cov8" title="1">{
        request, err := http.NewRequest(http.MethodPost, url, payload)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request.Header.Set(headerExtensionName, extensionName)
        return request, nil</span>
}

func sendRequest(httpClient HttpClient, request *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        return httpClient.Do(request)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package registration

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "time"
)

const (
        headerContentType  string = "Content-Type"
        routeSubscribeLogs string = "/2020-08-15/logs"
)

//requestTimeout     time.Duration = 5 * time.Second

// SubscribeLogs subscribes to the logs collection on the platform.
// We send a request to AWS to subscribe for logs, indicating on which port we
// are opening an HTTP server, to receive logs from AWS.
// When we are receiving logs on this HTTP server, we're pushing them in a channel
// tailed by the Logs Agent pipeline, these logs then go through the regular
// Logs Agent pipeline to finally be sent on the intake when we receive a FLUSH
// call from the Lambda function / client.
// logsType contains the type of logs for which we are subscribing, possible
// value: platform, extension and function.
func SubscribeLogs(id ID, url string, timeout time.Duration, payload json.Marshaler) error <span class="cov8" title="1">{

        jsonBytes, err := payload.MarshalJSON()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("SubscribeLogs: can't marshal subscribe JSON %v", err)
        }</span>

        <span class="cov8" title="1">request, err := buildLogRegistrationRequest(url, HeaderExtID, headerContentType, id, jsonBytes)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("SubscribeLogs: can't create the PUT request: %v", err)
        }</span>

        <span class="cov8" title="1">response, err := sendLogRegistrationRequest(&amp;http.Client{
                Transport: &amp;http.Transport{IdleConnTimeout: timeout},
                Timeout:   timeout,
        }, request)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("SubscribeLogs: while PUT subscribe request: %s", err)
        }</span>

        <span class="cov8" title="1">if !isValidHttpCode(response.StatusCode) </span><span class="cov8" title="1">{
                return fmt.Errorf("SubscribeLogs: received an HTTP %s", response.Status)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func BuildLogRegistrationPayload(uri string, logsType []string, timeoutMs int, maxBytes int, maxItems int) *LogSubscriptionPayload <span class="cov8" title="1">{
        destination := &amp;Destination{
                URI:      uri,
                Protocol: "HTTP",
        }
        buffering := &amp;Buffering{
                TimeoutMs: timeoutMs,
                MaxBytes:  maxBytes,
                MaxItems:  maxItems,
        }
        payload := &amp;LogSubscriptionPayload{
                Destination: *destination,
                Types:       logsType,
                Buffering:   *buffering,
        }
        return payload
}</span>

func buildLogRegistrationRequest(url string, headerExtID string, headerContentType string, id ID, payload []byte) (*http.Request, error) <span class="cov8" title="1">{
        request, err := http.NewRequest(http.MethodPut, url, bytes.NewBuffer(payload))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request.Header.Set(headerExtID, id.String())
        request.Header.Set(headerContentType, "application/json")
        return request, nil</span>
}

func sendLogRegistrationRequest(httpClient HttpClient, request *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        return httpClient.Do(request)
}</span>

func isValidHttpCode(statusCode int) bool <span class="cov8" title="1">{
        return statusCode &lt; 300
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package registration

import (
        "encoding/json"
)

type Destination struct {
        URI      string `json:"URI"`
        Protocol string `json:"protocol"`
}
type Buffering struct {
        MaxBytes  int `json:"maxBytes"`
        MaxItems  int `json:"maxItems"`
        TimeoutMs int `json:"timeoutMs"`
}
type LogSubscriptionPayload struct {
        Buffering   Buffering   `json:"buffering"`
        Destination Destination `json:"destination"`
        Types       []string    `json:"types"`
}

func (p *LogSubscriptionPayload) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // use an alias to avoid infinite recursion while serializing
        type LogSubscriptionPayloadAlias LogSubscriptionPayload
        return json.Marshal((*LogSubscriptionPayloadAlias)(p))
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package registration

import (
        "fmt"
        "net/http"
)

// ID is the extension ID within the AWS Extension environment.
type ID string

// String returns the string value for this ID.
func (i ID) String() string <span class="cov8" title="1">{
        return string(i)
}</span>

// HttpClient represents an Http Client
type HttpClient interface {
        Do(req *http.Request) (*http.Response, error)
}

func BuildURL(prefix string, route string) string <span class="cov8" title="1">{
        if len(prefix) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("http://localhost:9001%s", route)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("http://%s%s", prefix, route)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package serverless

import (
        "fmt"
        "os"
        "strings"
)

const (
        qualifierEnvVar = "AWS_LAMBDA_FUNCTION_VERSION"

        traceOriginMetadataKey   = "_dd.origin"
        traceOriginMetadataValue = "lambda"
        computeStatsKey          = "_dd.compute_stats"
        computeStatsValue        = "1"
        functionARNKey           = "function_arn"
        functionNameKey          = "functionname"
        regionKey                = "region"
        accountIDKey             = "account_id"
        awsAccountKey            = "aws_account"
        resourceKey              = "resource"
        executedVersionKey       = "executedversion"
)

func buildTagMap(arn string, configTags []string) map[string]string <span class="cov8" title="1">{
        tags := make(map[string]string)

        for _, tag := range configTags </span><span class="cov8" title="1">{
                splitTags := strings.Split(tag, ",")
                for _, singleTag := range splitTags </span><span class="cov8" title="1">{
                        tags = addTag(tags, singleTag)
                }</span>
        }

        <span class="cov8" title="1">tags = setIfNotEmpty(tags, traceOriginMetadataKey, traceOriginMetadataValue)
        tags = setIfNotEmpty(tags, computeStatsKey, computeStatsValue)
        tags = setIfNotEmpty(tags, functionARNKey, arn)

        parts := strings.Split(arn, ":")
        if len(parts) &lt; 6 </span><span class="cov8" title="1">{
                return tags
        }</span>

        <span class="cov8" title="1">tags = setIfNotEmpty(tags, regionKey, parts[3])
        tags = setIfNotEmpty(tags, awsAccountKey, parts[4])
        tags = setIfNotEmpty(tags, accountIDKey, parts[4])
        tags = setIfNotEmpty(tags, functionNameKey, parts[6])
        tags = setIfNotEmpty(tags, resourceKey, parts[6])

        qualifier := os.Getenv(qualifierEnvVar)
        if len(qualifier) &gt; 0 </span><span class="cov8" title="1">{
                if qualifier != "$LATEST" </span><span class="cov8" title="1">{
                        tags = setIfNotEmpty(tags, resourceKey, fmt.Sprintf("%s:%s", parts[6], qualifier))
                        tags = setIfNotEmpty(tags, executedVersionKey, qualifier)
                }</span>
        }

        <span class="cov8" title="1">return tags</span>
}

func buildTagsFromMap(tags map[string]string) []string <span class="cov8" title="1">{
        tagsMap := make(map[string]string)
        tagBlackList := []string{traceOriginMetadataKey, computeStatsKey}
        for k, v := range tags </span><span class="cov8" title="1">{
                tagsMap[k] = v
        }</span>
        <span class="cov8" title="1">for _, blackListKey := range tagBlackList </span><span class="cov8" title="1">{
                delete(tagsMap, blackListKey)
        }</span>
        <span class="cov8" title="1">tagsArray := make([]string, 0, len(tagsMap))
        for key, value := range tagsMap </span><span class="cov8" title="1">{
                tagsArray = append(tagsArray, fmt.Sprintf("%s:%s", key, value))
        }</span>
        <span class="cov8" title="1">return tagsArray</span>
}

func buildTracerTags(tags map[string]string) map[string]string <span class="cov8" title="1">{
        tagsMap := make(map[string]string)
        tagBlackList := []string{resourceKey}
        for k, v := range tags </span><span class="cov8" title="1">{
                tagsMap[k] = v
        }</span>
        <span class="cov8" title="1">for _, blackListKey := range tagBlackList </span><span class="cov8" title="1">{
                delete(tagsMap, blackListKey)
        }</span>
        <span class="cov8" title="1">return tagsMap</span>
}

func setIfNotEmpty(tagMap map[string]string, key string, value string) map[string]string <span class="cov8" title="1">{
        if key != "" </span><span class="cov8" title="1">{
                tagMap[key] = strings.ToLower(value)
        }</span>
        <span class="cov8" title="1">return tagMap</span>
}

func addTag(tagMap map[string]string, tag string) map[string]string <span class="cov8" title="1">{
        extract := strings.Split(tag, ":")
        if len(extract) == 2 </span><span class="cov8" title="1">{
                tagMap[strings.ToLower(extract[0])] = strings.ToLower(extract[1])
        }</span>
        <span class="cov8" title="1">return tagMap</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
